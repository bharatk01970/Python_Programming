import tkinter as tk
from tkinter import ttk, filedialog, messagebox, simpledialog
import pandas as pd
import json
import ast
import os
from typing import Dict, List, Any, Optional

class CSVProcessorGUI:
    def __init__(self, root):
        self.root = root
        self.root.title("CSV Dictionary Field Processor")
        self.root.geometry("700x500")
        
        # Data storage
        self.input_file_path = ""
        self.mapping_files = {}  # {'A': 'file2_path', 'C': 'file3_path'}
        self.df = None
        self.selected_fields = []
        self.dictionary_fields = {}
        self.selected_keys = {}
        self.processed_data = None
        self.mapping_data = {}
        
        self.setup_ui()
    
    def setup_ui(self):
        # Main frame
        main_frame = ttk.Frame(self.root, padding="10")
        main_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        
        # Configure grid weights
        self.root.columnconfigure(0, weight=1)
        self.root.rowconfigure(0, weight=1)
        main_frame.columnconfigure(1, weight=1)
        
        # File selection section
        ttk.Label(main_frame, text="1. Load Input File:", font=('TkDefaultFont', 10, 'bold')).grid(
            row=0, column=0, columnspan=2, sticky=tk.W, pady=(0, 5))
        
        ttk.Button(main_frame, text="Select Input File", 
                  command=self.load_input_file).grid(row=1, column=0, sticky=tk.W, pady=(0, 10))
        
        self.input_file_label = ttk.Label(main_frame, text="No file selected")
        self.input_file_label.grid(row=1, column=1, sticky=tk.W, padx=(10, 0), pady=(0, 10))
        
        # Mapping files section
        ttk.Label(main_frame, text="2. Load Mapping Files (Optional):", 
                 font=('TkDefaultFont', 10, 'bold')).grid(
            row=2, column=0, columnspan=2, sticky=tk.W, pady=(10, 5))
        
        mapping_frame = ttk.Frame(main_frame)
        mapping_frame.grid(row=3, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(0, 10))
        
        ttk.Button(mapping_frame, text="Add Mapping File", 
                  command=self.add_mapping_file).grid(row=0, column=0, sticky=tk.W)
        
        self.mapping_listbox = tk.Listbox(mapping_frame, height=3)
        self.mapping_listbox.grid(row=1, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(5, 0))
        mapping_frame.columnconfigure(0, weight=1)
        
        # Field selection section
        ttk.Label(main_frame, text="3. Select Fields:", 
                 font=('TkDefaultFont', 10, 'bold')).grid(
            row=4, column=0, columnspan=2, sticky=tk.W, pady=(10, 5))
        
        # Field selection frame
        field_frame = ttk.Frame(main_frame)
        field_frame.grid(row=5, column=0, columnspan=2, sticky=(tk.W, tk.E, tk.N, tk.S), pady=(0, 10))
        field_frame.columnconfigure(0, weight=1)
        main_frame.rowconfigure(5, weight=1)
        
        # Field listbox with scrollbar
        field_scroll_frame = ttk.Frame(field_frame)
        field_scroll_frame.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        field_scroll_frame.columnconfigure(0, weight=1)
        field_scroll_frame.rowconfigure(0, weight=1)
        
        self.field_listbox = tk.Listbox(field_scroll_frame, selectmode=tk.MULTIPLE, height=6)
        field_scrollbar = ttk.Scrollbar(field_scroll_frame, orient="vertical", command=self.field_listbox.yview)
        self.field_listbox.configure(yscrollcommand=field_scrollbar.set)
        
        self.field_listbox.grid(row=0, column=0, sticky=(tk.W, tk.E, tk.N, tk.S))
        field_scrollbar.grid(row=0, column=1, sticky=(tk.N, tk.S))
        
        # Process button
        ttk.Button(main_frame, text="Process Data", 
                  command=self.process_data, style='Accent.TButton').grid(
            row=6, column=0, columnspan=2, pady=10)
        
        # Export button
        self.export_button = ttk.Button(main_frame, text="Export Results", 
                                       command=self.export_data, state='disabled')
        self.export_button.grid(row=7, column=0, columnspan=2, pady=5)
        
        # Status bar
        self.status_var = tk.StringVar(value="Ready to load file...")
        status_bar = ttk.Label(main_frame, textvariable=self.status_var, 
                              relief=tk.SUNKEN, anchor=tk.W)
        status_bar.grid(row=8, column=0, columnspan=2, sticky=(tk.W, tk.E), pady=(10, 0))
    
    def load_input_file(self):
        file_path = filedialog.askopenfilename(
            title="Select Input File",
            filetypes=[("CSV files", "*.csv"), ("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if file_path:
            # Try multiple encodings to handle different file formats
            encodings_to_try = ['utf-8', 'latin-1', 'cp1252', 'iso-8859-1', 'utf-16']
            
            for encoding in encodings_to_try:
                try:
                    if file_path.endswith('.csv'):
                        self.df = pd.read_csv(file_path, encoding=encoding)
                    else:
                        self.df = pd.read_csv(file_path, delimiter='\t', encoding=encoding)
                    
                    self.input_file_path = file_path
                    self.input_file_label.config(text=os.path.basename(file_path))
                    
                    # Populate field listbox
                    self.field_listbox.delete(0, tk.END)
                    for col in self.df.columns:
                        self.field_listbox.insert(tk.END, col)
                    
                    self.status_var.set(f"Loaded file with {len(self.df)} rows and {len(self.df.columns)} columns (encoding: {encoding})")
                    return  # Success - exit the method
                    
                except UnicodeDecodeError:
                    continue  # Try next encoding
                except Exception as e:
                    # If it's not an encoding error, show the error
                    if encoding == encodings_to_try[-1]:  # Last encoding attempt
                        messagebox.showerror("Error", f"Failed to load file: {str(e)}")
                        self.status_var.set("Error loading file")
                    continue
            
            # If all encodings failed
            messagebox.showerror("Error", 
                "Failed to load file with any supported encoding. The file may be corrupted or in an unsupported format.")
            self.status_var.set("Error loading file - encoding issue")
    
    def add_mapping_file(self):
        if not hasattr(self, 'df') or self.df is None:
            messagebox.showwarning("Warning", "Please load the input file first")
            return
        
        # Select mapping file
        file_path = filedialog.askopenfilename(
            title="Select Mapping File",
            filetypes=[("CSV files", "*.csv"), ("Text files", "*.txt"), ("All files", "*.*")]
        )
        
        if file_path:
            try:
                # Load mapping file
                if file_path.endswith('.csv'):
                    mapping_df = pd.read_csv(file_path)
                else:
                    mapping_df = pd.read_csv(file_path, delimiter='\t')
                
                # Auto-detect which field this mapping is for
                input_fields = set(self.df.columns)
                mapping_fields = set(mapping_df.columns)
                
                # Find common field (intersection)
                common_fields = input_fields.intersection(mapping_fields)
                
                if not common_fields:
                    messagebox.showwarning("Warning", 
                        f"No matching columns found between input file and mapping file.\n"
                        f"Input file columns: {list(input_fields)}\n"
                        f"Mapping file columns: {list(mapping_fields)}")
                    return
                
                # Use the first common field found
                field_to_map = list(common_fields)[0]
                
                if len(common_fields) > 1:
                    # If multiple matches, let user choose
                    field_to_map = simpledialog.askstring(
                        "Multiple Matches Found",
                        f"Multiple matching columns found: {list(common_fields)}\n"
                        f"Enter the field name to use for mapping:",
                        initialvalue=field_to_map
                    )
                    
                    if not field_to_map or field_to_map not in common_fields:
                        messagebox.showwarning("Warning", "Invalid field selection")
                        return
                
                # Store mapping
                self.mapping_files[field_to_map] = file_path
                self.mapping_data[field_to_map] = mapping_df
                
                # Update listbox
                self.mapping_listbox.insert(tk.END, f"{field_to_map}: {os.path.basename(file_path)}")
                
                self.status_var.set(f"Added mapping for field '{field_to_map}' (auto-detected)")
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to load mapping file: {str(e)}")
    
    def split_multi_values(self, value):
        """Split comma or semicolon separated values"""
        if pd.isna(value) or value == "":
            return [""]
        
        value_str = str(value).strip()
        
        # Check for semicolon first, then comma
        if ';' in value_str:
            return [v.strip() for v in value_str.split(';') if v.strip()]
        elif ',' in value_str:
            return [v.strip() for v in value_str.split(',') if v.strip()]
        else:
            return [value_str]
    
    def is_dictionary_like(self, value):
        """Check if a value looks like a dictionary"""
        if pd.isna(value) or value == "":
            return False
        
        value_str = str(value).strip()
        
        # Check for JSON-like format
        if value_str.startswith('{') and value_str.endswith('}'):
            return True
        
        # Check for key:value or key=value patterns
        if ':' in value_str or '=' in value_str:
            return True
        
        return False
    
    def parse_dictionary_value(self, value):
        """Parse dictionary-like value into key-value pairs"""
        if pd.isna(value) or value == "":
            return {}
        
        value_str = str(value).strip()
        result = {}
        
        try:
            # Try JSON parsing first
            if value_str.startswith('{') and value_str.endswith('}'):
                result = json.loads(value_str)
                return result
        except:
            pass
        
        try:
            # Try ast.literal_eval for Python dict format
            result = ast.literal_eval(value_str)
            if isinstance(result, dict):
                return result
        except:
            pass
        
        # Manual parsing for key:value or key=value patterns
        try:
            # First try to split by semicolon (primary separator)
            if ';' in value_str:
                pairs = [p.strip() for p in value_str.split(';') if p.strip()]
            else:
                # If no semicolons, try splitting by comma carefully
                # Look for patterns like "key:value, key2:value2" or "key=value, key2=value2"
                pairs = []
                current_pair = ""
                parts = value_str.split(',')
                
                for part in parts:
                    current_pair += part.strip()
                    # Check if this looks like a complete key-value pair
                    if (':' in current_pair or '=' in current_pair):
                        # Count separators to ensure we have a complete pair
                        colon_count = current_pair.count(':')
                        equals_count = current_pair.count('=')
                        
                        # If we have exactly one separator, it's likely a complete pair
                        if (colon_count == 1 and equals_count == 0) or (equals_count == 1 and colon_count == 0):
                            pairs.append(current_pair)
                            current_pair = ""
                        else:
                            current_pair += ", "  # Add back the comma for multi-value
                    else:
                        current_pair += ", "  # Add back the comma
                
                # Add any remaining part
                if current_pair.strip():
                    pairs.append(current_pair.strip())
                
                # If we couldn't split properly, treat the whole thing as pairs
                if not pairs:
                    pairs = [value_str]
            
            # Parse each pair
            for pair in pairs:
                pair = pair.strip()
                if ':' in pair:
                    key, val = pair.split(':', 1)
                    result[key.strip()] = val.strip()
                elif '=' in pair:
                    key, val = pair.split('=', 1)
                    result[key.strip()] = val.strip()
                    
        except Exception as e:
            # If parsing fails, return empty dict
            pass
        
        return result
    
    def detect_dictionary_fields(self, selected_fields):
        """Detect which fields contain dictionary-like values"""
        dict_fields = {}
        
        for field in selected_fields:
            if field in self.df.columns:
                # Sample some non-null values to check
                sample_values = self.df[field].dropna().head(10)
                
                dict_count = 0
                all_keys = set()
                
                for value in sample_values:
                    if self.is_dictionary_like(value):
                        dict_count += 1
                        parsed = self.parse_dictionary_value(value)
                        all_keys.update(parsed.keys())
                
                # If more than 50% of sampled values look like dictionaries
                if dict_count > len(sample_values) * 0.5:
                    dict_fields[field] = list(all_keys)
        
        return dict_fields
    
    def show_key_selection_popup(self, field, available_keys):
        """Show popup for key selection in dictionary fields"""
        popup = tk.Toplevel(self.root)
        popup.title(f"Select Keys for Field: {field}")
        popup.geometry("400x300")
        popup.transient(self.root)
        popup.grab_set()
        
        ttk.Label(popup, text=f"Select keys to include from field '{field}':", 
                 font=('TkDefaultFont', 10, 'bold')).pack(pady=10)
        
        # Key selection listbox
        key_frame = ttk.Frame(popup)
        key_frame.pack(fill=tk.BOTH, expand=True, padx=10, pady=5)
        
        key_listbox = tk.Listbox(key_frame, selectmode=tk.MULTIPLE)
        key_scrollbar = ttk.Scrollbar(key_frame, orient="vertical", command=key_listbox.yview)
        key_listbox.configure(yscrollcommand=key_scrollbar.set)
        
        key_listbox.pack(side=tk.LEFT, fill=tk.BOTH, expand=True)
        key_scrollbar.pack(side=tk.RIGHT, fill=tk.Y)
        
        for key in available_keys:
            key_listbox.insert(tk.END, key)
        
        # Select all by default
        key_listbox.select_set(0, tk.END)
        
        selected_keys = []
        
        def on_confirm():
            nonlocal selected_keys
            selected_indices = key_listbox.curselection()
            selected_keys = [available_keys[i] for i in selected_indices]
            popup.destroy()
        
        def on_cancel():
            nonlocal selected_keys
            selected_keys = []
            popup.destroy()
        
        button_frame = ttk.Frame(popup)
        button_frame.pack(pady=10)
        
        ttk.Button(button_frame, text="Confirm", command=on_confirm).pack(side=tk.LEFT, padx=5)
        ttk.Button(button_frame, text="Cancel", command=on_cancel).pack(side=tk.LEFT, padx=5)
        
        popup.wait_window()
        return selected_keys
    
    def process_data(self):
        if self.df is None:
            messagebox.showwarning("Warning", "Please load an input file first")
            return
        
        # Get selected fields
        selected_indices = self.field_listbox.curselection()
        if not selected_indices:
            messagebox.showwarning("Warning", "Please select at least one field")
            return
        
        self.selected_fields = [self.field_listbox.get(i) for i in selected_indices]
        
        # Detect dictionary fields
        self.dictionary_fields = self.detect_dictionary_fields(self.selected_fields)
        
        # Show key selection popups for dictionary fields
        self.selected_keys = {}
        for field, available_keys in self.dictionary_fields.items():
            if available_keys:
                selected = self.show_key_selection_popup(field, available_keys)
                if selected:
                    self.selected_keys[field] = selected
                else:
                    messagebox.showinfo("Info", f"No keys selected for field '{field}'. Skipping dictionary processing for this field.")
        
        # Process the data
        try:
            self.processed_data = self.process_dataframe()
            self.export_button.config(state='normal')
            self.status_var.set(f"Processing complete. {len(self.processed_data)} rows generated.")
            
        except Exception as e:
            messagebox.showerror("Error", f"Failed to process data: {str(e)}")
            self.status_var.set("Processing failed")
    
    def process_dataframe(self):
        """Process the dataframe according to the algorithm"""
        result_rows = []
        
        for index, row in self.df.iterrows():
            # Process each row and handle multi-values
            self.process_single_row(row, result_rows)
        
        # Apply mappings if available
        if self.mapping_data:
            result_rows = self.apply_mappings(result_rows)
        
        return result_rows
    
    def process_single_row(self, row, result_rows):
        """Process a single row, handling multi-values and dictionary fields with Cartesian product"""
        import itertools
        
        # Collect all field expansions
        field_expansions = {}
        
        # Process regular fields for multi-values
        for field in self.selected_fields:
            if field not in self.dictionary_fields:
                values = self.split_multi_values(row[field])
                # Remove empty values and duplicates
                unique_values = []
                for val in values:
                    if val and val not in unique_values:
                        unique_values.append(val)
                if not unique_values:
                    unique_values = [""]
                field_expansions[field] = unique_values
        
        # Process dictionary fields
        for field in self.dictionary_fields:
            if field in self.selected_keys:
                # Parse the dictionary field (it's a single field containing key-value pairs)
                parsed_dict = self.parse_dictionary_value(row[field])
                
                # For each selected key, collect all values
                for key in self.selected_keys[field]:
                    if key in parsed_dict:
                        # The value might be multi-valued (comma/semicolon separated)
                        key_values = self.split_multi_values(parsed_dict[key])
                        # Remove empty values and duplicates
                        unique_values = []
                        for val in key_values:
                            if val and val not in unique_values:
                                unique_values.append(val)
                        if not unique_values:
                            unique_values = [""]
                        field_expansions[f"{field}_{key}"] = unique_values
                    else:
                        field_expansions[f"{field}_{key}"] = [""]
        
        # Create Cartesian product of all field values
        if field_expansions:
            field_names = list(field_expansions.keys())
            field_values = list(field_expansions.values())
            
            # Generate all combinations using Cartesian product
            for combination in itertools.product(*field_values):
                new_row = {}
                for field_name, value in zip(field_names, combination):
                    new_row[field_name] = value
                
                # Check if this combination already exists to avoid duplicates
                if new_row not in result_rows:
                    result_rows.append(new_row)
    
    def expand_multivalued_fields(self, base_row, dict_expansions, result_rows):
        """Handle multiple values by creating separate rows - DEPRECATED"""
        # This method is now replaced by process_single_row
        pass
    
    def apply_mappings(self, result_rows):
        """Apply mapping files to add additional columns"""
        for field, mapping_df in self.mapping_data.items():
            if field in self.selected_fields:
                # Create mapping dictionary
                if len(mapping_df.columns) >= 2:
                    key_col = mapping_df.columns[0]  # First column as key
                    value_col = mapping_df.columns[1]  # Second column as value
                    
                    mapping_dict = dict(zip(mapping_df[key_col], mapping_df[value_col]))
                    
                    # Apply mapping to result rows
                    for row in result_rows:
                        if field in row:
                            mapped_value = mapping_dict.get(row[field], "")
                            row[f"{field}_mapped"] = mapped_value
        
        return result_rows
    
    def show_completion_popup(self):
        """Show popup asking user what to do next"""
        popup = tk.Toplevel(self.root)
        popup.title("Processing Complete")
        popup.geometry("300x150")
        popup.transient(self.root)
        popup.grab_set()
        
        ttk.Label(popup, text="Data processing completed successfully!", 
                 font=('TkDefaultFont', 10, 'bold')).pack(pady=20)
        
        ttk.Label(popup, text="What would you like to do next?").pack(pady=5)
        
        button_frame = ttk.Frame(popup)
        button_frame.pack(pady=20)
        
        def continue_working():
            popup.destroy()
        
        def close_application():
            popup.destroy()
            self.root.destroy()  # Use destroy() instead of quit()
        
        ttk.Button(button_frame, text="Continue Working", 
                  command=continue_working).pack(side=tk.LEFT, padx=10)
        ttk.Button(button_frame, text="Close Application", 
                  command=close_application).pack(side=tk.LEFT, padx=10)
    
    def export_data(self):
        if not self.processed_data:
            messagebox.showwarning("Warning", "No processed data to export")
            return
        
        file_path = filedialog.asksaveasfilename(
            title="Save Processed Data",
            defaultextension=".csv",
            filetypes=[("CSV files", "*.csv"), ("Excel files", "*.xlsx"), ("All files", "*.*")]
        )
        
        if file_path:
            try:
                df_export = pd.DataFrame(self.processed_data)
                
                if file_path.endswith('.xlsx'):
                    df_export.to_excel(file_path, index=False)
                else:
                    df_export.to_csv(file_path, index=False)
                
                messagebox.showinfo("Success", f"Data exported successfully to {os.path.basename(file_path)}")
                self.status_var.set(f"Data exported to {os.path.basename(file_path)}")
                
                # Show completion popup after export
                self.show_completion_popup()
                
            except Exception as e:
                messagebox.showerror("Error", f"Failed to export data: {str(e)}")

def main():
    root = tk.Tk()
    app = CSVProcessorGUI(root)
    root.mainloop()

if __name__ == "__main__":
    main()